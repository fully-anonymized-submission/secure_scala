{
    "sublist": " sublist.scala\n\n```scala\nimport stainless.annotation._\nimport stainless.collection._\n\nobject SublistChecker {\n  def isSublist[T](a: List[T], b: List[T]): Boolean = {\n    require(a.nonEmpty ==> b.nonEmpty)\n\n    def isPrefix(l1: List[T], l2: List[T]): Boolean = {\n      l1.forall((x, i) => l2.isDefinedAt(i) && l2(i) == x)\n    }\n\n    b.sliding(a.length).exists(isPrefix(a, _))\n  }.ensuring(res => \n    // Reflexivity: A list is a sublist of itself\n    (a.isEmpty || a == b) ==> res &&\n    // Transitivity: If a is a sublist of b and b is a sublist of c, then a is a sublist of c\n    (forall((c: List[T]) => isSublist(b, c) ==> (isSublist(a, c) == res))\n  )\n}\n```\n\nThis Scala program defines a function `isSublist` using the Stainless framework to verify that it satisfies reflexivity and transitivity properties. The function checks if one list is a sublist of another by sliding over the larger list and checking for prefixes. The `ensuring` clause specifies the properties to be verified.",
    "fibonacci": "```scala\nimport stainless.annotation._\nimport stainless.collection._\nimport stainless.lang._\n\nobject Fibonacci {\n  def fib(n: BigInt): BigInt = {\n    require(n >= 0)\n    if (n == 0) 0\n    else if (n == 1) 1\n    else fib(n - 1) + fib(n - 2)\n  } ensuring(res => res >= 0)\n\n  def isEven(n: BigInt): Boolean = {\n    n % 2 == 0\n  }\n\n  def thirdFibIsEven(n: BigInt): Boolean = {\n    require(n >= 0)\n    if (n < 3) true\n    else isEven(fib(n)) && thirdFibIsEven(n - 3)\n  } holds\n\n  def main(args: Array[String]): Unit = {\n    println(fib(10))\n  }\n```",
    "factorial": "```scala\nimport stainless.annotation._\nimport stainless.lang._\nimport stainless.math.BigInt._\n\nobject Factorial {\n  def factorial(n: BigInt): BigInt = {\n    require(n >= 0)\n    decreases(n)\n    if (n == 0) BigInt(1)\n    else n * factorial(n - 1)\n  }\n\n  def factorialIsCorrect(n: BigInt): Boolean = {\n    require(n >= 0)\n    factorial(n) >= n\n  } holds\n}\n```"
}