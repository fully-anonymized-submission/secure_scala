{
    "matrixMultiplication": "Sure, here is a simple Scala code generator for a function that multiplies two matrices:\n\n```scala\nobject GeneratedFunctions {\n  def matrixMultiplication(matrixA: Array[Array[Double]], matrixB: Array[Array[Double]]): Array[Array[Double]] = {\n    val rowsA = matrixA.length\n    val colsA = matrixA(0).length\n    val rowsB = matrixB.length\n    val colsB = matrixB(0).length\n\n    if (colsA != rowsB) throw new Exception(\"Matrices cannot be multiplied\")\n\n    val matrixC = Array.ofDim[Double](rowsA, colsB)\n\n    for (i <- 0 until rowsA) {\n      for (j <- 0 until colsB) {\n        for (k <- 0 until colsA) {\n          matrixC(i)(j) += matrixA(i)(k) * matrixB(k)(j)\n        }\n      }\n    }\n\n    matrixC\n  }\n}\n```\n",
    "averageAge": "Sure, here is the Scala code for the problem:\n\n```scala\nobject GeneratedFunctions {\n    def averageAge(ages: List[Int]): Double = {\n        if (ages.isEmpty) 0.0\n        else ages.sum.toDouble / ages.length\n    }\n}\n```\n\nThis function works by checking if the list of ages is empty. If it is, it returns 0.0 as the average age. If it isn't, it calculates the average by summing up all the ages in the list and dividing by the number of ages. The result is then converted to a Double for precision.\n",
    "fibonacci": "Sure, here's a simple implementation of a function to calculate the n-th Fibonacci number in Scala:\n\n```scala\nobject GeneratedFunctions {\n    def fibonacci(n: Int): Int = {\n        @annotation.tailrec\n        def go(n: Int, a: Int, b: Int): Int =\n            if (n == 0) a\n            else go(n - 1, b, a + b)\n        go(n, 0, 1)\n    }\n}\n```\n\nThis implementation uses a tail recursive function to calculate the Fibonacci numbers. The tail recursive function `go` is defined inside the `fibonacci` function, and it takes three parameters: `n`, `a`, and `b`. `n` is the current index in the Fibonacci sequence (starting from 0), `a` is the value of the `(n-1)`th Fibonacci number, and `b` is the value of the `n`th Fibonacci number.\n\nThe `go` function recursively calls itself with decreasing `n`, and increasing `a` and `b` according to the Fibonacci sequence rules. When `n` reaches 0, it returns `a`, which is the n-th Fibonacci number.\n",
    "convolution": "Here is the Scala code for implementing a matrix convolution operation:\n\n```scala\nobject GeneratedFunctions {\n  def convolution(matrix: Array[Array[Double]], kernel: Array[Array[Double]]): Array[Array[Double]] = {\n    val m = matrix.length\n    val n = matrix(0).length\n    val k = kernel.length\n\n    val paddedMatrix = Array.ofDim[Double](m + 2 * (k / 2), n + 2 * (k / 2))\n    for (i <- 0 until m; j <- 0 until n) {\n      paddedMatrix(i + k / 2)(j + k / 2) = matrix(i)(j)\n    }\n\n    val result = Array.ofDim[Double](m, n)\n    for (i <- k / 2 until m + k / 2; j <- k / 2 until n + k / 2) {\n      var sum = 0.0\n      for (x <- 0 until k; y <- 0 until k) {\n        sum += paddedMatrix(i - k / 2 + x)(j - k / 2 + y) * kernel(x)(y)\n      }\n      result(i - k / 2)(j - k / 2) = sum\n    }\n\n    result\n  }\n}\n```\nPlease note that this code assumes that the kernel is square and has an odd size, which is a common assumption for convolution operations.\n"
}